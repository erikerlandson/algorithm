[/ QuickBook Document version 1.5 ]

[section:edit_distance edit_distance]

[/license
Copyright (c) 2014 Erik Erlandson

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
]

[section:sections Sections]

* [link the_boost_algorithm_library.Sequence.edit_distance.overview Overview]
* [link the_boost_algorithm_library.Sequence.edit_distance.arguments Arguments]
* [link the_boost_algorithm_library.Sequence.edit_distance.cost_functions Cost Functions]
* [link the_boost_algorithm_library.Sequence.edit_distance.equality_relation Equality Relation]
* [link the_boost_algorithm_library.Sequence.edit_distance.script Edit Script Handler]
* [link the_boost_algorithm_library.Sequence.edit_distance.substitution Substitution]
* [link the_boost_algorithm_library.Sequence.edit_distance.max_cost Max Cost]

[endsect]

[section:overview Overview]

The header file `boost/algorithm/sequence/edit_distance.hpp` provides an implementation of the [@http://en.wikipedia.org/wiki/Edit_distance edit distance] between two sequences (aka Levenshtein distance, aka string distance, aka string difference):

``
#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using namespace boost::algorithm::sequence::parameter;

// Returns the edit distance between two sequences.
// Sequences may be any valid range object supporting forward iteration.
d = edit_distance(seq1, seq2)

// Returns the edit distance, and calls special handler methods from object 'script_handler'
// on the correspondiung "script" of edit operations:
d = edit_distance(seq1, seq2, _script = script_handler)

// Sequences need not be the same type:
d = edit_distance(my_vector, my_list | boost::adaptors::reversed);
``

The implementation of `edit_distance` is based on a variation of the Dijkstra Single Source Shortest Path algorithm, tuned for the particular structure of an edit graph. It is efficient on long sequences with localized areas of differences (e.g. computing the diff of two similar files). Whenever conditions permit, an even faster specialized distance algorithm is automatically applied, from:
[#myers_algorithm]
[pre
An O(ND) Difference Algorithm and its Variations
Eugene W. Myers
Dept of Computer Science, University of Arizona
]

[endsect]

[section:arguments Arguments to edit_distance()]

The `edit_distance` function accepts a variety of optional parameters, using the Boost.Parameter named argument library:
[table:id Optional Arguments to edit_distance
[[Argument][Description][Default]]
[
    [``_cost = cost_object``]
    [define customized cost functions for edit operations insertion, deletion and substitution]
    [unit cost: cost of insertion, deletion and substitution are all 1]
]
[
    [``_equal = equal_object``]
    [define a customized equality relation between sequence elements]
    [standard equality: requires that the `==` operator is defined for sequence elements]
]
[
    [``_script = script_handler``]
    [the sequence, or "script," of edit operations is passed to methods defined on `script_handler` for collection or other processing by the calling code]
    [edit script information is ignored: only the edit distance is returned]
]
[
    [``_substitution = boolean_arg``]
    [Enable or disable substitution.  Note that `boolean_arg` may be either of type `bool` (enable/disable at run time), `boost::false_type()` or `boost::true_type()` (enable/disable at compile time).  When substitution is disabled, only insertion and deletion are considered as edit operations.]
    [`boost::false_type()` -- substitution is disabled at compile time.] 
]
[
    [``_max_cost = cost_value``]
    [Provide a maxium edit distance ("cost").  If the edit cost exceeds this maximum, computation of the true mimimum edit distance will halt, and the remainder of the computation will use a fast linear-time fallback, which will not yield the true minimum distance.]
    [No maximum: the minimum edit distance will always be computed fully]
]
[
    [``_max_cost_exception = bool_value``]
    [If `bool_value` == `true`, then `edit_distance` will throw an exception if edit distance exceeds the value specified by `_max_cost`, instead of completing with the fast fallback.]
    [`false`]
]
]

[endsect]

[section:cost_functions Cost Functions]
A user specified object may be provided to `edit_distance` that defines customized cost functions for the edit operations.  

A cost function object must define the methods `insertion`, `deletion` and `substitution`.  The cost type used by `edit_distance` can be explicitly defined by defining `cost_type`, or it may be automatically inferred from the return type of the cost functions.

[tip When substitution is disabled at compile-time, then the `substitution` method is not required.]

The cost function defaults to "unit cost."  The cost of insertion, deletion and substitution is always exactly 1.

The following example demonstrates the use of customized cost functions:

``
#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using namespace boost::algorithm::sequence::parameter;

struct custom_cost {
    // If cost_type is not defined, it will be automatically inferred from
    // the return type of the cost functions below:
    typedef int cost_type;

    // inserting or deleting a space is free:
    int insertion(char a) const { return (a == ' ') ? 0 : 1; }
    int deletion(char a) const { return (a == ' ') ? 0 : 1; }

    // defining this method is not required if substitution has been 
    // disabled at compile time.
    int substitution(char a, char b) const { return 1; }
};

// Invoke edit_distance with the custom cost functions:
int d = edit_distance("spaces here",  "  spaces   there ",  _cost = custom_cost());
``

[tip Although edit distances are typically integer values, the cost type can also be defined as a floating point.]
[note When a cost function is asymmetric (for example, if the cost of deletion is not equal to cost of insertion), `edit_distance` will not behave as a true distance metric, as the symmetry property is violated: `edit_distance(a, b)` != `edit_distance(b, a)`.]
[caution Cost functions are expected to always return values >= 0.  The behavior of `edit_distance` is undefined on functions that can return negative cost values.]

[endsect]


[section:equality_relation Equality Relation]

A user specified equality relation may be provided to `edit_distance`, that defines when the distance algorithms consider two sequence elements to be identical.  

The equality relation defaults to applying operator `==` to sequence elements.

The following example demonstrates the use of a customized equality relation:

``
#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using namespace boost::algorithm::sequence::parameter;

struct custom_equal {
    // any elements of the same case are considered identical
    bool operator()(char a, char b) const { return tolower(a) == tolower(b); }
};

// apply the customized definition of element equality:
int d = edit_distance("case", "CaSe", _equal = custom_equal());
``
[endsect]

[section:script Edit Script Handler]

The minimum edit distance between two sequences corresponds to a particular order of edit operations, referred to as an "edit script."  The user may provide an object that defines methods for processing ("handling") the resulting script of operations.

An edit script handler must define the methods: `insertion`, `deletion`, `substitution` and `equality`.  

[tip When substitution is disabled at compile-time, then the `substitution` method is not required.]

By default, the `edit_distance` function provides no script handling object.  All information about the ordering of edit operations is ignored, and only the final edit distance is returned.

The following example demonstrates the definition of an edit script handler:

``
#include <cstdlib>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_io.hpp>
using boost::make_tuple;
using std::cout;

#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using namespace boost::algorithm::sequence::parameter;

struct script_handler {
    // an edit script handler that writes edit operations to stdout:
    void insertion(char element, int cost) { cout << make_tuple('+', element, cost); }
    void deletion(char element, int cost) { cout << make_tuple('-', element, cost); }

    // optional if substitution is disabled at compile time
    void substitution(char e1, char e2, int cost) { cout << make_tuple(':', e1, e2, cost); }

    // cost is known to be zero by definition
    void equality(char e1, char e2) { cout << make_tuple('=', e1, e2); }
};

// A script handler is passed as a non-const reference, and must be declared prior to 
// calling edit_distance()
script_handler handler;

// the edit script of operations will be passed to the methods of handler:
int d = edit_distance("cat in the hat", "hat on the cat", _script = handler);
``

[endsect]

[section:substitution Substitution]

The substitution operation is not necessary for computing an edit distance, as it is equivalent to a deletion followed by an insertion.  Common applications of edit distance, e.g. the standard unix file diff, do not make use of subsitution.  The [link myers_algorithm Myers edit distance algorithm] implicitly assumes no substitution.  Therefore, substitution is not enabled by default in `edit_distance`.

Substitution is enabled or disabled via the `_substitution` named parameter.  The function supports two modes of enable/disable:  If the argument is passed a value of type `bool` (i.e. `true`, `false` or a `bool` variable), then substitution is enabled/disabled at run-time.  However, if the argument is passed `boost::false_type()` or `boost::true_type()`, substitution is enabled or disabled at compile time.  This is faster, as the boolean check is not present in the code.  Compile-time disabled (the default) is the fastest of all, as no subsitution checking or code is ever compiled at all.

The following example demonstrates the `_substitution` parameter:
``
#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using namespace boost::algorithm::sequence::parameter;

// turn substitution on or off at run-time
bool sub_switch = true;
d = edit_distance("cat", "bat", _substitution = sub_switch);

// enable substitution at compile-time
d = edit_distance("cat", "hat", _substitution = boost::true_type());

// disable substitution at compile-time (the default)
d = edit_distance("cat", "hat", _substitution = boost::false_type());
``

[endsect]

[section:max_cost Max Cost]

The `edit_distance` function is implemented to be efficient when comparing two sequences that differ only in localized areas.  For example, comparing two similar text files that differ only by localized edits, or comparing two sequences of DNA that differ only at certain localized mutations.

However, edit distance in general always has a worst case time and space complexity of O(NxM), where N and M are the lengths of the two sequences being compared.  For long sequences, this worst case can quickly become intractible.

The `edit_distance` function provides an argument `_max_cost`, which takes a numeric maximum cost value.  If the function finds that the maximum cost exceeds this value, it will halt its normal computations and fall back to a fast linear algorithm to complete the rest of the computation.  This fallback can obviously not provide a minimum distance, however its answer will build on the 'full' computations performed up to that point.

If an approximate fallback is not desired, the function may also be directed to throw an exception if the computation exceeds a given maximum cost.  The argument `_max_cost_exception` controls this behavior.

The following example demonstrates `_max_cost` and `_max_cost_exception`:

``
#include <boost/algorithm/sequence/edit_distance.hpp>

using boost::algorithm::sequence::edit_distance;
using boost::algorithm::sequence::max_edit_cost_exception;
using namespace boost::algorithm::sequence::parameter;

// get the distance between two long sequences, but fall back to approximation if the distance is too large.
d = edit_distance(long_sequence, another_long_sequence, _max_cost = 1000);

// throw exception if the distance grows too large
try {
    d = edit_distance(long_sequence, another_long_sequence, _max_cost = 1000, _max_cost_exception = true);
} catch (max_edit_cost_exception& e) {
    // handle the exception
}
``

[endsect]

[endsect]

[/ File edit_distance.qbk
Copyright 2014 Erik Erlandson
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt).
]
